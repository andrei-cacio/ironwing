{"name":"ironwingjs","tagline":"ironwingjs is a lightweight front-end library which offers CRUD manipulation over a RESTful API","body":"# About\r\n\r\nIn a few words, **ironwingjs** is a lightweight, isomorphic, framework-agnostic JavaScript library. **ironginwjs** is ment to be super easy to use and easy to integrate on any app. Out of the box it offers CRUD manipulation over a REST API interface.\r\n\r\n### Installation\r\n\r\n```sh\r\n$ npm install ironwing\r\n```\r\n\r\n### How it works\r\n\r\nIronwing was ment to be simple. So let's say we have the `/api/users` endpoint and we want to manipulate the data that's coming from that API.\r\n\r\n```javascript\r\n// Tell ironwing to interact with the /api base path for all operations\r\nironwing.base = '/api';\r\n\r\n// Fetch a collection and make a GET hit on /api/users\r\nironwing('users').then((users) => {\r\n  // do something with users collection\r\n});\r\n\r\n// Fetch a single resource\r\nironwing('users', 100).then((user) => {\r\n  // do something with the fetched user resource\r\n});\r\n\r\n// Update a resource\r\nironwing('users', 100).then((user) => {\r\n  // access the resource attributes via the .attr object\r\n  user.attr.name = 'Carl';\r\n  user.update();\r\n});\r\n\r\n// Delete a resource\r\nironwing('users', 100).then((user) => {\r\n  user.delete();\r\n});\r\n```\r\n\r\n#### REST\r\nHere is a map of the endpoints *ironwing* will hit on every operation\r\n\r\n| Action            | Method | URL        | Returns    |\r\n| ----------------- | -------|------------|----------- |\r\n| ironwing('users', 1) | GET    | /users/:id | Model      |\r\n| ironwing('users')    | GET    | /users     | Collection |\r\n| user.update()     | PUT    | /users/:id | Model      |\r\n| ironwing.create()        | POST   | /users     | Model      |\r\n| user.delete()     | DELETE | /users/:id | NULL       |\r\n\r\n### Core concepts\r\n___\r\n\r\n#### Adapters\r\n\r\nAn adapter is an object which follows a predefined interface so that it can be integrated with ironwing. Out of the box, ironwingjs comes with a ***JSON*** adapter which is an intermediate object that communicates with the `XMLHttpRequest` API. The developer doesn't interact directly with the adapter. The adapter is used *“under the hood”* by **ironwing**. The main purpose of adapters is to easily modify how **ironwing** interacts with the server. Anyone can write their own adapter and use it with ironwingjs. By default, ironwing loads the ***JSON*** adapter. You only have to specify the API's path so ironwing can communicate with your service properly.\r\nHere's a simple example:\r\n```javascript\r\nimport ironwing from './ironwing';\r\n\r\nironwing.base = '/api';\r\n```\r\n### Storage\r\n\r\nBy default, **ironwing** has a local *(heap)* storage. After **ironwing** fetches a new model, by default it stores it locally for later use. So for example if we were to fetch data from an endpoint called ***/users/100***:\r\n```javascript\r\nironwing('users', 100).then((user) => { \r\n    console.log(user.attr.name); \r\n});\r\n```\r\nWe can later on retrieve that model from memory without any extra trips to the server, by simply calling\r\n```javascript \r\nvar userModel =  ironwing.storage.find('users', 100);\r\n```\r\nOr, if we fetched a collection\r\n```javascript\r\nironwing('users',).then((users) => { \r\n  console.log(users.length); \r\n});\r\n```\r\nwe can later on get one or all users type model\r\n```javascript\r\nvar usersCollection =  ironwing.storage.findAll('users');\r\n```\r\nFor the moment, only the default storage can be used. In future releases we hope to implement a way to switch between storage implementations like an adapter for *local storage* so you can save the state of your models after refresh.\r\n\r\n### Proxy objects\r\n\r\nThe constructor method ironwing() is basically a factory method which returns `Model` instances. Each model exposes CRUD methods for manipulating your data. However, **ironwing** never modifies the raw JSON data directly. It exposes a ***proxy object*** as an intermediate. Each model object has a `.attr` object which contains a camel cased transformation of the JSON response. Everything you edit on the *attr proxy object*, it will be later synced with the original raw response and sent to the back-end. This technique offers control over what gets edited and what doesn't. In future releases, with the help of the proxy object, some cool features can be added like validators on attributes.\r\n\r\nA quick create and update example:\r\n```javascript\r\nimport ironwing from './ironwing';\r\n\r\nvar userData = {\r\n    first_name: 'Jon',\r\n    last_name: 'Doe';\r\n};\r\n\r\nironwing.base = '/api';\r\nironwing.create('users', userData).then((userModel) => {\r\n    /**\r\n    * a POST request is sent to the server\r\n    * /api/users\r\n    */\r\n    userModel.attr.firstName = 'Jon';\r\n    userModel.attr.lastName = 'Doe';\r\n\r\n    userModel.update().then(() => {\r\n        /**\r\n        * a PUT request is sent to the server\r\n        * /api/users/:id\r\n        */\r\n    });\r\n});\r\n```\r\n\r\n---\r\n\r\n# ironwingjs in [Today Software Magazine](http://www.todaysoftmag.com)\r\n\r\n[Introducing Ironwingjs](http://www.todaysoftmag.com/article/1703/introducing-ironwingjs)\r\n\r\nLicense\r\n----\r\n\r\nMIT\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}